// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package database

import (
	"context"
	"database/sql"
)

const createLog = `-- name: CreateLog :one
INSERT INTO logs (id, level, source, message, metadata, created_at)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, level, source, message, metadata, created_at
`

type CreateLogParams struct {
	ID        string         `json:"id"`
	Level     string         `json:"level"`
	Source    string         `json:"source"`
	Message   string         `json:"message"`
	Metadata  sql.NullString `json:"metadata"`
	CreatedAt string         `json:"created_at"`
}

func (q *Queries) CreateLog(ctx context.Context, arg CreateLogParams) (Log, error) {
	row := q.db.QueryRowContext(ctx, createLog,
		arg.ID,
		arg.Level,
		arg.Source,
		arg.Message,
		arg.Metadata,
		arg.CreatedAt,
	)
	var i Log
	err := row.Scan(
		&i.ID,
		&i.Level,
		&i.Source,
		&i.Message,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (id, session_id, role, content, created_at)
VALUES (?, ?, ?, ?, ?)
RETURNING id, session_id, role, content, created_at
`

type CreateMessageParams struct {
	ID        string `json:"id"`
	SessionID string `json:"session_id"`
	Role      string `json:"role"`
	Content   string `json:"content"`
	CreatedAt string `json:"created_at"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, createMessage,
		arg.ID,
		arg.SessionID,
		arg.Role,
		arg.Content,
		arg.CreatedAt,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Role,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const createSchedule = `-- name: CreateSchedule :one
INSERT INTO schedules (id, skill, cron_expression, input, enabled, created_at)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, skill, cron_expression, input, enabled, created_at
`

type CreateScheduleParams struct {
	ID             string `json:"id"`
	Skill          string `json:"skill"`
	CronExpression string `json:"cron_expression"`
	Input          string `json:"input"`
	Enabled        int64  `json:"enabled"`
	CreatedAt      string `json:"created_at"`
}

func (q *Queries) CreateSchedule(ctx context.Context, arg CreateScheduleParams) (Schedule, error) {
	row := q.db.QueryRowContext(ctx, createSchedule,
		arg.ID,
		arg.Skill,
		arg.CronExpression,
		arg.Input,
		arg.Enabled,
		arg.CreatedAt,
	)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.Skill,
		&i.CronExpression,
		&i.Input,
		&i.Enabled,
		&i.CreatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (id, user_id, created_at, updated_at)
VALUES (?, ?, ?, ?)
RETURNING id, user_id, created_at, updated_at
`

type CreateSessionParams struct {
	ID        string `json:"id"`
	UserID    string `json:"user_id"`
	CreatedAt string `json:"created_at"`
	UpdatedAt string `json:"updated_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, createSession,
		arg.ID,
		arg.UserID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSkill = `-- name: CreateSkill :one
INSERT INTO skills (id, name, version, location, permissions, metadata, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, version, location, permissions, metadata, created_at
`

type CreateSkillParams struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	Version     string `json:"version"`
	Location    string `json:"location"`
	Permissions string `json:"permissions"`
	Metadata    string `json:"metadata"`
	CreatedAt   string `json:"created_at"`
}

func (q *Queries) CreateSkill(ctx context.Context, arg CreateSkillParams) (Skill, error) {
	row := q.db.QueryRowContext(ctx, createSkill,
		arg.ID,
		arg.Name,
		arg.Version,
		arg.Location,
		arg.Permissions,
		arg.Metadata,
		arg.CreatedAt,
	)
	var i Skill
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Location,
		&i.Permissions,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (id, session_id, skill, input, status, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, session_id, skill, input, output, status, error, created_at, updated_at
`

type CreateTaskParams struct {
	ID        string `json:"id"`
	SessionID string `json:"session_id"`
	Skill     string `json:"skill"`
	Input     string `json:"input"`
	Status    string `json:"status"`
	CreatedAt string `json:"created_at"`
	UpdatedAt string `json:"updated_at"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, createTask,
		arg.ID,
		arg.SessionID,
		arg.Skill,
		arg.Input,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Skill,
		&i.Input,
		&i.Output,
		&i.Status,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (id, channel, channel_user_id, created_at)
VALUES (?, ?, ?, ?)
RETURNING id, channel, channel_user_id, created_at
`

type CreateUserParams struct {
	ID            string `json:"id"`
	Channel       string `json:"channel"`
	ChannelUserID string `json:"channel_user_id"`
	CreatedAt     string `json:"created_at"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.Channel,
		arg.ChannelUserID,
		arg.CreatedAt,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Channel,
		&i.ChannelUserID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteLog = `-- name: DeleteLog :exec
DELETE FROM logs WHERE id = ?
`

func (q *Queries) DeleteLog(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteLog, id)
	return err
}

const deleteLogsOlderThan = `-- name: DeleteLogsOlderThan :exec
DELETE FROM logs WHERE created_at < ?
`

func (q *Queries) DeleteLogsOlderThan(ctx context.Context, createdAt string) error {
	_, err := q.db.ExecContext(ctx, deleteLogsOlderThan, createdAt)
	return err
}

const deleteMessage = `-- name: DeleteMessage :exec
DELETE FROM messages WHERE id = ?
`

func (q *Queries) DeleteMessage(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteMessage, id)
	return err
}

const deleteSchedule = `-- name: DeleteSchedule :exec
DELETE FROM schedules WHERE id = ?
`

func (q *Queries) DeleteSchedule(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSchedule, id)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE id = ?
`

func (q *Queries) DeleteSession(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, id)
	return err
}

const deleteSkill = `-- name: DeleteSkill :exec
DELETE FROM skills WHERE id = ?
`

func (q *Queries) DeleteSkill(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSkill, id)
	return err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM tasks WHERE id = ?
`

func (q *Queries) DeleteTask(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTask, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = ?
`

func (q *Queries) DeleteUser(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getLogByID = `-- name: GetLogByID :one
SELECT id, level, source, message, metadata, created_at FROM logs
WHERE id = ? LIMIT 1
`

func (q *Queries) GetLogByID(ctx context.Context, id string) (Log, error) {
	row := q.db.QueryRowContext(ctx, getLogByID, id)
	var i Log
	err := row.Scan(
		&i.ID,
		&i.Level,
		&i.Source,
		&i.Message,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getLogsByDateRange = `-- name: GetLogsByDateRange :many
SELECT id, level, source, message, metadata, created_at FROM logs
WHERE created_at >= ? AND created_at <= ?
ORDER BY created_at DESC
LIMIT ?
`

type GetLogsByDateRangeParams struct {
	CreatedAt   string `json:"created_at"`
	CreatedAt_2 string `json:"created_at_2"`
	Limit       int64  `json:"limit"`
}

func (q *Queries) GetLogsByDateRange(ctx context.Context, arg GetLogsByDateRangeParams) ([]Log, error) {
	rows, err := q.db.QueryContext(ctx, getLogsByDateRange, arg.CreatedAt, arg.CreatedAt_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Log
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Source,
			&i.Message,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogsByLevel = `-- name: GetLogsByLevel :many
SELECT id, level, source, message, metadata, created_at FROM logs
WHERE level = ?
ORDER BY created_at DESC
LIMIT ?
`

type GetLogsByLevelParams struct {
	Level string `json:"level"`
	Limit int64  `json:"limit"`
}

func (q *Queries) GetLogsByLevel(ctx context.Context, arg GetLogsByLevelParams) ([]Log, error) {
	rows, err := q.db.QueryContext(ctx, getLogsByLevel, arg.Level, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Log
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Source,
			&i.Message,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogsBySource = `-- name: GetLogsBySource :many
SELECT id, level, source, message, metadata, created_at FROM logs
WHERE source = ?
ORDER BY created_at DESC
LIMIT ?
`

type GetLogsBySourceParams struct {
	Source string `json:"source"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) GetLogsBySource(ctx context.Context, arg GetLogsBySourceParams) ([]Log, error) {
	rows, err := q.db.QueryContext(ctx, getLogsBySource, arg.Source, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Log
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Source,
			&i.Message,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessageByID = `-- name: GetMessageByID :one
SELECT id, session_id, role, content, created_at FROM messages
WHERE id = ? LIMIT 1
`

func (q *Queries) GetMessageByID(ctx context.Context, id string) (Message, error) {
	row := q.db.QueryRowContext(ctx, getMessageByID, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Role,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const getMessagesBySessionID = `-- name: GetMessagesBySessionID :many
SELECT id, session_id, role, content, created_at FROM messages
WHERE session_id = ?
ORDER BY created_at ASC
`

func (q *Queries) GetMessagesBySessionID(ctx context.Context, sessionID string) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, getMessagesBySessionID, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Role,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduleByID = `-- name: GetScheduleByID :one
SELECT id, skill, cron_expression, input, enabled, created_at FROM schedules
WHERE id = ? LIMIT 1
`

func (q *Queries) GetScheduleByID(ctx context.Context, id string) (Schedule, error) {
	row := q.db.QueryRowContext(ctx, getScheduleByID, id)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.Skill,
		&i.CronExpression,
		&i.Input,
		&i.Enabled,
		&i.CreatedAt,
	)
	return i, err
}

const getSchedulesBySkill = `-- name: GetSchedulesBySkill :many
SELECT id, skill, cron_expression, input, enabled, created_at FROM schedules
WHERE skill = ?
ORDER BY created_at DESC
`

func (q *Queries) GetSchedulesBySkill(ctx context.Context, skill string) ([]Schedule, error) {
	rows, err := q.db.QueryContext(ctx, getSchedulesBySkill, skill)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Schedule
	for rows.Next() {
		var i Schedule
		if err := rows.Scan(
			&i.ID,
			&i.Skill,
			&i.CronExpression,
			&i.Input,
			&i.Enabled,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, user_id, created_at, updated_at FROM sessions
WHERE id = ? LIMIT 1
`

func (q *Queries) GetSessionByID(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSessionByID, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSessionsByUserID = `-- name: GetSessionsByUserID :many
SELECT id, user_id, created_at, updated_at FROM sessions
WHERE user_id = ?
ORDER BY created_at DESC
`

func (q *Queries) GetSessionsByUserID(ctx context.Context, userID string) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, getSessionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSkillByID = `-- name: GetSkillByID :one
SELECT id, name, version, location, permissions, metadata, created_at FROM skills
WHERE id = ? LIMIT 1
`

func (q *Queries) GetSkillByID(ctx context.Context, id string) (Skill, error) {
	row := q.db.QueryRowContext(ctx, getSkillByID, id)
	var i Skill
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Location,
		&i.Permissions,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getSkillByName = `-- name: GetSkillByName :one
SELECT id, name, version, location, permissions, metadata, created_at FROM skills
WHERE name = ? LIMIT 1
`

func (q *Queries) GetSkillByName(ctx context.Context, name string) (Skill, error) {
	row := q.db.QueryRowContext(ctx, getSkillByName, name)
	var i Skill
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Location,
		&i.Permissions,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT id, session_id, skill, input, output, status, error, created_at, updated_at FROM tasks
WHERE id = ? LIMIT 1
`

func (q *Queries) GetTaskByID(ctx context.Context, id string) (Task, error) {
	row := q.db.QueryRowContext(ctx, getTaskByID, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Skill,
		&i.Input,
		&i.Output,
		&i.Status,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTasksBySessionID = `-- name: GetTasksBySessionID :many
SELECT id, session_id, skill, input, output, status, error, created_at, updated_at FROM tasks
WHERE session_id = ?
ORDER BY created_at DESC
`

func (q *Queries) GetTasksBySessionID(ctx context.Context, sessionID string) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, getTasksBySessionID, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Skill,
			&i.Input,
			&i.Output,
			&i.Status,
			&i.Error,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByChannel = `-- name: GetUserByChannel :one
SELECT id, channel, channel_user_id, created_at FROM users
WHERE channel = ? AND channel_user_id = ? LIMIT 1
`

type GetUserByChannelParams struct {
	Channel       string `json:"channel"`
	ChannelUserID string `json:"channel_user_id"`
}

func (q *Queries) GetUserByChannel(ctx context.Context, arg GetUserByChannelParams) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByChannel, arg.Channel, arg.ChannelUserID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Channel,
		&i.ChannelUserID,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, channel, channel_user_id, created_at FROM users
WHERE id = ? LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Channel,
		&i.ChannelUserID,
		&i.CreatedAt,
	)
	return i, err
}

const listSchedules = `-- name: ListSchedules :many
SELECT id, skill, cron_expression, input, enabled, created_at FROM schedules
ORDER BY created_at DESC
`

func (q *Queries) ListSchedules(ctx context.Context) ([]Schedule, error) {
	rows, err := q.db.QueryContext(ctx, listSchedules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Schedule
	for rows.Next() {
		var i Schedule
		if err := rows.Scan(
			&i.ID,
			&i.Skill,
			&i.CronExpression,
			&i.Input,
			&i.Enabled,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSkills = `-- name: ListSkills :many
SELECT id, name, version, location, permissions, metadata, created_at FROM skills
ORDER BY created_at DESC
`

func (q *Queries) ListSkills(ctx context.Context) ([]Skill, error) {
	rows, err := q.db.QueryContext(ctx, listSkills)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Skill
	for rows.Next() {
		var i Skill
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Version,
			&i.Location,
			&i.Permissions,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, channel, channel_user_id, created_at FROM users
ORDER BY created_at DESC
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Channel,
			&i.ChannelUserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSchedule = `-- name: UpdateSchedule :one
UPDATE schedules
SET cron_expression = ?, input = ?, enabled = ?
WHERE id = ?
RETURNING id, skill, cron_expression, input, enabled, created_at
`

type UpdateScheduleParams struct {
	CronExpression string `json:"cron_expression"`
	Input          string `json:"input"`
	Enabled        int64  `json:"enabled"`
	ID             string `json:"id"`
}

func (q *Queries) UpdateSchedule(ctx context.Context, arg UpdateScheduleParams) (Schedule, error) {
	row := q.db.QueryRowContext(ctx, updateSchedule,
		arg.CronExpression,
		arg.Input,
		arg.Enabled,
		arg.ID,
	)
	var i Schedule
	err := row.Scan(
		&i.ID,
		&i.Skill,
		&i.CronExpression,
		&i.Input,
		&i.Enabled,
		&i.CreatedAt,
	)
	return i, err
}

const updateSession = `-- name: UpdateSession :one
UPDATE sessions
SET updated_at = ?
WHERE id = ?
RETURNING id, user_id, created_at, updated_at
`

type UpdateSessionParams struct {
	UpdatedAt string `json:"updated_at"`
	ID        string `json:"id"`
}

func (q *Queries) UpdateSession(ctx context.Context, arg UpdateSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, updateSession, arg.UpdatedAt, arg.ID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSkill = `-- name: UpdateSkill :one
UPDATE skills
SET version = ?, location = ?, permissions = ?, metadata = ?
WHERE id = ?
RETURNING id, name, version, location, permissions, metadata, created_at
`

type UpdateSkillParams struct {
	Version     string `json:"version"`
	Location    string `json:"location"`
	Permissions string `json:"permissions"`
	Metadata    string `json:"metadata"`
	ID          string `json:"id"`
}

func (q *Queries) UpdateSkill(ctx context.Context, arg UpdateSkillParams) (Skill, error) {
	row := q.db.QueryRowContext(ctx, updateSkill,
		arg.Version,
		arg.Location,
		arg.Permissions,
		arg.Metadata,
		arg.ID,
	)
	var i Skill
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Location,
		&i.Permissions,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const updateTask = `-- name: UpdateTask :one
UPDATE tasks
SET output = ?, status = ?, error = ?, updated_at = ?
WHERE id = ?
RETURNING id, session_id, skill, input, output, status, error, created_at, updated_at
`

type UpdateTaskParams struct {
	Output    sql.NullString `json:"output"`
	Status    string         `json:"status"`
	Error     sql.NullString `json:"error"`
	UpdatedAt string         `json:"updated_at"`
	ID        string         `json:"id"`
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, updateTask,
		arg.Output,
		arg.Status,
		arg.Error,
		arg.UpdatedAt,
		arg.ID,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Skill,
		&i.Input,
		&i.Output,
		&i.Status,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
